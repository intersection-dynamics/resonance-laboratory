"""
engines/twodefect_exchange_3d_cu_engine.py

Canonical 3D constrained substrate model (CuPy / GPU)
for emergent exchange statistics.

Model summary
-------------
- 3D cubic lattice with periodic boundary conditions:
      Lx x Ly x Lz sites, N = Lx * Ly * Lz
- Local Hilbert space per site:
      H_site = span{|0>, |1>}  (empty / defect)

- Physical subspace H_phys:
      exactly TWO defects in the whole lattice (two 1's, rest 0's).
  Basis states are labeled by unordered pairs of *distinct* sites:
      (a, b) with 0 <= a < b < N.
  Here a and b are single site indices encoding 3D coordinates.

- 3D locality:
  The lattice is a 3D torus. Each site has up to 6 neighbors:
      ±x, ±y, ±z with wrap-around.

  Dynamics are generated by a local hopping Hamiltonian:
      H = sum_over_nn ( -J c_i^† c_j + h.c. )
  restricted to the two-defect hard-core subspace.
  In the reduced basis this becomes a tight-binding Hamiltonian on the
  configuration graph of two defects on a 3D lattice.

- Phase-tagged sectors:
  Following the exchange-statistics paper, we define phase-labelled
  initial states via【turn1file9†L79-L87】:

      |psi_phi(0)> = exp(i * phi * N_hat) |psi>,

  with N_hat distinguishing sectors intended to acquire the phase.

  Here we define N_hat as a Z2-valued operator derived from the *3D
  coordinates* of both defects:

      For site index s, let (x_s, y_s, z_s) be its coordinates.
      For basis state |a, b>, define:

          N(a, b) = (x_a + y_a + z_a + x_b + y_b + z_b) mod 2   (∈ {0, 1})

  This uses the bipartite structure of the cubic lattice and reflects
  a parity-like degree of freedom tied to the 3D geometry. It splits
  the configuration space into two sectors that we phase-tag.

- Stability metric:
  For each phase phi we compute【turn1file9†L87-L96】:

      F_phi(t) = |<psi_phi(0)|psi_phi(t)>|^2
      S(phi) = (1/T) ∫_0^T F_phi(t) dt

  via discrete time steps and trapezoidal integration.

Implementation notes
--------------------
- All heavy linear algebra runs on GPU using CuPy.
- We build the Hamiltonian H as a dense (dim x dim) cp.ndarray,
  where dim = C(N, 2) = N*(N-1)/2.
- Time evolution uses eigen-decomposition:
      H = V diag(E) V^†
  with cp.linalg.eigh and evolution in the eigenbasis.

Contract
--------
This is a pure physics engine:
- NO file I/O.
- Deterministic given params["seed"].
- Public entry point:

      run_experiment(params: dict) -> results: dict

Returned results dict is suitable for saving by an experiment script.
"""

from __future__ import annotations

from typing import Any, Dict, List, Tuple

import math
import time

import numpy as np
import cupy as cp
from cupy.typing import NDArray as CpArray


# ---------------------------------------------------------------------------
# RNG helper
# ---------------------------------------------------------------------------

def _set_seed(seed: int | None) -> None:
    """
    Initialize both NumPy and CuPy RNGs.
    """
    if seed is not None:
        np.random.seed(seed)
        cp.random.seed(seed)


# ---------------------------------------------------------------------------
# 3D lattice indexing helpers
# ---------------------------------------------------------------------------

def coord_to_index(x: int, y: int, z: int, Lx: int, Ly: int, Lz: int) -> int:
    """
    Map (x, y, z) to a single site index in [0, N-1].
    """
    return x + Lx * (y + Ly * z)


def index_to_coord(s: int, Lx: int, Ly: int, Lz: int) -> Tuple[int, int, int]:
    """
    Inverse of coord_to_index.
    """
    z = s // (Lx * Ly)
    rem = s % (Lx * Ly)
    y = rem // Lx
    x = rem % Lx
    return x, y, z


def build_neighbors_3d(Lx: int, Ly: int, Lz: int) -> List[List[int]]:
    """
    Build a neighbor list for all sites on a 3D cubic lattice with
    periodic boundary conditions. Each site has up to 6 neighbors
    (±x, ±y, ±z directions).

    Returns:
        neighbors: list of length N; neighbors[s] is a list of neighbor
                   site indices for site s.
    """
    N = Lx * Ly * Lz
    neighbors: List[List[int]] = [[] for _ in range(N)]

    for s in range(N):
        x, y, z = index_to_coord(s, Lx, Ly, Lz)

        # +x, -x
        xp = (x + 1) % Lx
        xm = (x - 1) % Lx
        yp = (y + 0) % Ly
        ym = (y + 0) % Ly
        zp = (z + 0) % Lz
        zm = (z + 0) % Lz  # not used; see below

        # Actually we need ±x, ±y, ±z; fix each separately
        # +x, -x
        neighbors[s].append(coord_to_index(xp, y, z, Lx, Ly, Lz))
        neighbors[s].append(coord_to_index(xm, y, z, Lx, Ly, Lz))

        # +y, -y
        yp = (y + 1) % Ly
        ym = (y - 1) % Ly
        neighbors[s].append(coord_to_index(x, yp, z, Lx, Ly, Lz))
        neighbors[s].append(coord_to_index(x, ym, z, Lx, Ly, Lz))

        # +z, -z
        zp = (z + 1) % Lz
        zm = (z - 1) % Lz
        neighbors[s].append(coord_to_index(x, y, zp, Lx, Ly, Lz))
        neighbors[s].append(coord_to_index(x, y, zm, Lx, Ly, Lz))

    return neighbors


# ---------------------------------------------------------------------------
# Two-defect basis and operators
# ---------------------------------------------------------------------------

def build_two_defect_basis(N: int) -> List[Tuple[int, int]]:
    """
    Build the two-defect basis on a lattice with N sites.

    Basis states are unordered pairs (a, b) with 0 <= a < b < N,
    representing defects at sites a and b (hard-core, no double
    occupancy).
    """
    basis: List[Tuple[int, int]] = []
    for a in range(N):
        for b in range(a + 1, N):
            basis.append((a, b))
    return basis


def build_index_map(basis: List[Tuple[int, int]]) -> Dict[Tuple[int, int], int]:
    """
    Map basis labels (a, b) to integer indices 0..dim-1.
    """
    return {state: idx for idx, state in enumerate(basis)}


def build_parity_operator_3d(
    basis: List[Tuple[int, int]],
    Lx: int,
    Ly: int,
    Lz: int,
) -> CpArray[cp.float64]:
    """
    Build diagonal elements of N_hat in the two-defect basis, using
    3D coordinates of both defects:

        N(a, b) = (x_a + y_a + z_a + x_b + y_b + z_b) mod 2

    This Z2-valued operator is tied to the bipartite structure of the
    cubic lattice and splits H_phys into two parity sectors.
    """
    dim = len(basis)
    diag = np.empty(dim, dtype=np.float64)

    for k, (a, b) in enumerate(basis):
        xa, ya, za = index_to_coord(a, Lx, Ly, Lz)
        xb, yb, zb = index_to_coord(b, Lx, Ly, Lz)
        val = (xa + ya + za + xb + yb + zb) % 2
        diag[k] = float(val)

    return cp.asarray(diag)


def build_hamiltonian_3d(
    Lx: int,
    Ly: int,
    Lz: int,
    J: float,
    basis: List[Tuple[int, int]],
    index_map: Dict[Tuple[int, int], int],
    neighbors: List[List[int]],
) -> CpArray[cp.complex128]:
    """
    Build dense Hamiltonian for two hardcore defects on a 3D torus
    with nearest-neighbor hopping amplitude J.

    Procedure:
      - Each basis state is a pair (a, b), a < b.
      - For each defect (at a or b), we attempt hops to all neighbors
        of that site, with amplitude -J, provided we don't violate
        hard-core (i.e., destination != other defect).
      - The resulting pair (a', b) or (a, b') is sorted into (min, max)
        and mapped back to a basis index via index_map.
      - We Hermitize at the end: H = (H + H^†) / 2.
    """
    dim = len(basis)
    H = cp.zeros((dim, dim), dtype=cp.complex128)

    def add_hop(state_from: Tuple[int, int], state_to: Tuple[int, int], amp: complex):
        i_from = index_map[state_from]
        i_to = index_map[state_to]
        H[i_to, i_from] += amp

    for (a, b) in basis:
        # Hop defect at a
        for na in neighbors[a]:
            if na == b:  # can't land on other defect
                continue
            new_state = (na, b)
            if new_state[0] > new_state[1]:
                new_state = (new_state[1], new_state[0])
            add_hop((a, b), new_state, -J)

        # Hop defect at b
        for nb in neighbors[b]:
            if nb == a:
                continue
            new_state = (a, nb)
            if new_state[0] > new_state[1]:
                new_state = (new_state[1], new_state[0])
            add_hop((a, b), new_state, -J)

    # Hermitize explicitly
    H = 0.5 * (H + H.conj().T)
    return H


# ---------------------------------------------------------------------------
# Initial state and time evolution
# ---------------------------------------------------------------------------

def build_initial_state(
    dim: int,
    mode: str = "random",
) -> CpArray[cp.complex128]:
    """
    Build a base state |psi> in H_phys.

    Currently supported:
        mode="random": random complex state over the whole
                       two-defect basis, then normalized.
    """
    if mode == "random":
        real = cp.random.normal(size=dim)
        imag = cp.random.normal(size=dim)
        psi = real + 1j * imag
    else:
        raise ValueError(f"Unknown initial state mode: {mode}")

    norm = cp.linalg.norm(psi)
    if norm == 0:
        raise ValueError("Generated zero-norm state.")
    psi /= norm
    return psi


def compute_eigendecomposition(
    H: CpArray[cp.complex128],
) -> Tuple[CpArray[cp.float64], CpArray[cp.complex128]]:
    """
    Diagonalize H on the GPU:

        H = V diag(E) V^†

    Returns:
        evals: (dim,) real eigenvalues
        evecs: (dim, dim) eigenvectors as columns
    """
    evals, evecs = cp.linalg.eigh(H)
    return evals, evecs


def time_evolve_fidelity(
    evals: CpArray[cp.float64],
    evecs: CpArray[cp.complex128],
    psi0: CpArray[cp.complex128],
    T: float,
    dt: float,
) -> Tuple[np.ndarray, np.ndarray]:
    """
    Compute fidelity F(t) = |<psi0 | psi(t)>|^2 on [0, T] with step dt.

    Uses the eigenbasis representation:
        psi0 = V c,
        psi(t) = V diag(e^{-i E t}) c
    and overlap <psi0|psi(t)> = c^† diag(e^{-i E t}) c.
    """
    # Represent psi0 in eigenbasis
    coeffs = evecs.conj().T @ psi0  # (dim,)
    coeffs_conj = coeffs.conj()

    n_steps = int(math.floor(T / dt)) + 1
    times_cp = cp.linspace(0.0, T, n_steps, dtype=cp.float64)
    fidelities_cp = cp.empty_like(times_cp)

    for k in range(n_steps):
        t = times_cp[k]
        phase = cp.exp(-1j * evals * t)
        psi_t_coeffs = coeffs * phase
        overlap = cp.dot(coeffs_conj, psi_t_coeffs)
        fidelities_cp[k] = cp.abs(overlap) ** 2

    times = cp.asnumpy(times_cp)
    fidelities = cp.asnumpy(fidelities_cp)
    return times, fidelities


def time_average_stability(times: np.ndarray, fidelities: np.ndarray) -> float:
    """
    S(phi) = (1/T) ∫_0^T F_phi(t) dt
    using trapezoidal rule on the sampled times.
    """
    T = float(times[-1] - times[0])
    if T <= 0.0:
        return float(fidelities[0])
    integral = float(np.trapz(fidelities, times))
    return float(integral / T)


# ---------------------------------------------------------------------------
# Public engine entry point
# ---------------------------------------------------------------------------

def run_experiment(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Core entry point for this 3D engine.

    Expected params keys:
        - Lx, Ly, Lz (int): lattice dimensions
        - J (float): hopping amplitude
        - T (float): total evolution time
        - dt (float): time step
        - phases (list of float): phase values to test
        - seed (int or None): RNG seed
        - init_mode (str): initial state mode ("random")

    Returns:
        results dict with keys:
            - "params": effective parameters used
            - "times": list of time arrays (one per phase)
            - "fidelities": list of fidelity arrays (one per phase)
            - "stabilities": dict str(phi) -> S(phi)
            - "diagnostics": basic info about the run
    """
    t_start = time.time()

    # Defaults
    Lx = int(params.get("Lx", 4))
    Ly = int(params.get("Ly", 4))
    Lz = int(params.get("Lz", 4))
    J = float(params.get("J", 1.0))
    T = float(params.get("T", 10.0))
    dt = float(params.get("dt", 0.1))
    phases_in = params.get("phases", [0.0, 0.5 * math.pi, math.pi])
    seed = params.get("seed", None)
    init_mode = params.get("init_mode", "random")

    phases = [float(phi) for phi in phases_in]

    _set_seed(seed)

    # Lattice and basis
    N = Lx * Ly * Lz
    basis = build_two_defect_basis(N)
    index_map = build_index_map(basis)
    dim = len(basis)

    # Neighbors and operators
    neighbors = build_neighbors_3d(Lx, Ly, Lz)
    N_diag_cp = build_parity_operator_3d(basis, Lx, Ly, Lz)

    # Hamiltonian
    H_cp = build_hamiltonian_3d(
        Lx=Lx,
        Ly=Ly,
        Lz=Lz,
        J=J,
        basis=basis,
        index_map=index_map,
        neighbors=neighbors,
    )

    # Eigen-decomposition
    evals_cp, evecs_cp = compute_eigendecomposition(H_cp)

    # Initial base state |psi>
    psi_base_cp = build_initial_state(dim, mode=init_mode)

    all_times: List[np.ndarray] = []
    all_fid: List[np.ndarray] = []
    stabilities: Dict[str, float] = {}

    for phi in phases:
        # |psi_phi(0)> = exp(i * phi * N_hat) |psi>
        phase_factor_cp = cp.exp(1j * float(phi) * N_diag_cp)
        psi_phi0_cp = phase_factor_cp * psi_base_cp

        times, fidelities = time_evolve_fidelity(
            evals=evals_cp,
            evecs=evecs_cp,
            psi0=psi_phi0_cp,
            T=T,
            dt=dt,
        )
        S_phi = time_average_stability(times, fidelities)

        all_times.append(times)
        all_fid.append(fidelities)
        stabilities[f"{phi:.6f}"] = S_phi

    t_end = time.time()

    # Diagnostics
    evals_np = cp.asnumpy(evals_cp)
    diagnostics: Dict[str, Any] = {
        "Lx": Lx,
        "Ly": Ly,
        "Lz": Lz,
        "N_sites": N,
        "dim": dim,
        "n_phases": len(phases),
        "T": T,
        "dt": dt,
        "runtime_sec": t_end - t_start,
        "eig_min": float(evals_np.min()),
        "eig_max": float(evals_np.max()),
    }

    results: Dict[str, Any] = {
        "params": {
            "Lx": Lx,
            "Ly": Ly,
            "Lz": Lz,
            "J": J,
            "T": T,
            "dt": dt,
            "phases": phases,
            "seed": seed,
            "init_mode": init_mode,
        },
        "times": [t.tolist() for t in all_times],
        "fidelities": [f.tolist() for f in all_fid],
        "stabilities": stabilities,
        "diagnostics": diagnostics,
    }

    return results
